// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_WordByWordEntry: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsWordByWordEntry(bb: ByteBuffer) -> com_quranic_wholequran_fbs_WordByWordEntry { return com_quranic_wholequran_fbs_WordByWordEntry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case id = 6
    case transliteration = 8
    case meaning = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: UInt64 { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var transliteration: String? { let o = _accessor.offset(VTOFFSET.transliteration.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var transliterationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.transliteration.v) }
  public var meaning: String? { let o = _accessor.offset(VTOFFSET.meaning.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var meaningSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.meaning.v) }
  public static func startWordByWordEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(key: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: key, def: 0, at: VTOFFSET.key.p) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(transliteration: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transliteration, at: VTOFFSET.transliteration.p) }
  public static func add(meaning: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: meaning, at: VTOFFSET.meaning.p) }
  public static func endWordByWordEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWordByWordEntry(
    _ fbb: inout FlatBufferBuilder,
    key: UInt64 = 0,
    idOffset id: Offset = Offset(),
    transliterationOffset transliteration: Offset = Offset(),
    meaningOffset meaning: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_WordByWordEntry.startWordByWordEntry(&fbb)
    com_quranic_wholequran_fbs_WordByWordEntry.add(key: key, &fbb)
    com_quranic_wholequran_fbs_WordByWordEntry.add(id: id, &fbb)
    com_quranic_wholequran_fbs_WordByWordEntry.add(transliteration: transliteration, &fbb)
    com_quranic_wholequran_fbs_WordByWordEntry.add(meaning: meaning, &fbb)
    return com_quranic_wholequran_fbs_WordByWordEntry.endWordByWordEntry(&fbb, start: __start)
  }
  public static func sortVectorOfWordByWordEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: UInt64, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_WordByWordEntry? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: UInt64.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_WordByWordEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_SurahWBW: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahWBW(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahWBW { return com_quranic_wholequran_fbs_SurahWBW(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case wbw = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var wbwCount: Int32 { let o = _accessor.offset(VTOFFSET.wbw.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func wbw(at index: Int32) -> com_quranic_wholequran_fbs_WordByWordEntry? { let o = _accessor.offset(VTOFFSET.wbw.v); return o == 0 ? nil : com_quranic_wholequran_fbs_WordByWordEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func wbwBy(key: UInt64) -> com_quranic_wholequran_fbs_WordByWordEntry? { let o = _accessor.offset(VTOFFSET.wbw.v); return o == 0 ? nil : com_quranic_wholequran_fbs_WordByWordEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startSurahWBW(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(wbw: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: wbw, at: VTOFFSET.wbw.p) }
  public static func endSurahWBW(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurahWBW(
    _ fbb: inout FlatBufferBuilder,
    wbwVectorOffset wbw: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahWBW.startSurahWBW(&fbb)
    com_quranic_wholequran_fbs_SurahWBW.addVectorOf(wbw: wbw, &fbb)
    return com_quranic_wholequran_fbs_SurahWBW.endSurahWBW(&fbb, start: __start)
  }
}

