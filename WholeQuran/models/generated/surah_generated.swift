// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_Ayah: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsAyah(bb: ByteBuffer) -> com_quranic_wholequran_fbs_Ayah { return com_quranic_wholequran_fbs_Ayah(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case no = 4
    case words = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var no: Int32 { let o = _accessor.offset(VTOFFSET.no.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var wordsCount: Int32 { let o = _accessor.offset(VTOFFSET.words.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func words(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.words.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startAyah(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(no: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: no, def: 0, at: VTOFFSET.no.p) }
  public static func addVectorOf(words: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: words, at: VTOFFSET.words.p) }
  public static func endAyah(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAyah(
    _ fbb: inout FlatBufferBuilder,
    no: Int32 = 0,
    wordsVectorOffset words: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_Ayah.startAyah(&fbb)
    com_quranic_wholequran_fbs_Ayah.add(no: no, &fbb)
    com_quranic_wholequran_fbs_Ayah.addVectorOf(words: words, &fbb)
    return com_quranic_wholequran_fbs_Ayah.endAyah(&fbb, start: __start)
  }
  public static func sortVectorOfAyah(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: Int32, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_Ayah? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: Int32.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_Ayah(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_Surah: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurah(bb: ByteBuffer) -> com_quranic_wholequran_fbs_Surah { return com_quranic_wholequran_fbs_Surah(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case no = 4
    case ayahs = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var no: Int32 { let o = _accessor.offset(VTOFFSET.no.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var ayahsCount: Int32 { let o = _accessor.offset(VTOFFSET.ayahs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ayahs(at index: Int32) -> com_quranic_wholequran_fbs_Ayah? { let o = _accessor.offset(VTOFFSET.ayahs.v); return o == 0 ? nil : com_quranic_wholequran_fbs_Ayah(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func ayahsBy(key: Int32) -> com_quranic_wholequran_fbs_Ayah? { let o = _accessor.offset(VTOFFSET.ayahs.v); return o == 0 ? nil : com_quranic_wholequran_fbs_Ayah.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startSurah(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(no: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: no, def: 0, at: VTOFFSET.no.p) }
  public static func addVectorOf(ayahs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ayahs, at: VTOFFSET.ayahs.p) }
  public static func endSurah(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurah(
    _ fbb: inout FlatBufferBuilder,
    no: Int32 = 0,
    ayahsVectorOffset ayahs: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_Surah.startSurah(&fbb)
    com_quranic_wholequran_fbs_Surah.add(no: no, &fbb)
    com_quranic_wholequran_fbs_Surah.addVectorOf(ayahs: ayahs, &fbb)
    return com_quranic_wholequran_fbs_Surah.endSurah(&fbb, start: __start)
  }
  public static func sortVectorOfSurah(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: Int32, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_Surah? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: Int32.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_Surah(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

