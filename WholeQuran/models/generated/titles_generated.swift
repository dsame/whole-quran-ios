// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_SurahTitle: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahTitle(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahTitle { return com_quranic_wholequran_fbs_SurahTitle(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case no = 4
    case title = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var no: Int32 { let o = _accessor.offset(VTOFFSET.no.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var title: String? { let o = _accessor.offset(VTOFFSET.title.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var titleSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.title.v) }
  public static func startSurahTitle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(no: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: no, def: 0, at: VTOFFSET.no.p) }
  public static func add(title: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: title, at: VTOFFSET.title.p) }
  public static func endSurahTitle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurahTitle(
    _ fbb: inout FlatBufferBuilder,
    no: Int32 = 0,
    titleOffset title: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahTitle.startSurahTitle(&fbb)
    com_quranic_wholequran_fbs_SurahTitle.add(no: no, &fbb)
    com_quranic_wholequran_fbs_SurahTitle.add(title: title, &fbb)
    return com_quranic_wholequran_fbs_SurahTitle.endSurahTitle(&fbb, start: __start)
  }
  public static func sortVectorOfSurahTitle(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: Int32, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahTitle? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: Int32.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_SurahTitle(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_SurahTitlesI18n: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahTitlesI18n(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahTitlesI18n { return com_quranic_wholequran_fbs_SurahTitlesI18n(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case lang = 4
    case titles = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var lang: String! { let o = _accessor.offset(VTOFFSET.lang.v); return _accessor.string(at: o) }
  public var langSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.lang.v) }
  public var titlesCount: Int32 { let o = _accessor.offset(VTOFFSET.titles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func titles(at index: Int32) -> com_quranic_wholequran_fbs_SurahTitle? { let o = _accessor.offset(VTOFFSET.titles.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahTitle(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func titlesBy(key: Int32) -> com_quranic_wholequran_fbs_SurahTitle? { let o = _accessor.offset(VTOFFSET.titles.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahTitle.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startSurahTitlesI18n(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(lang: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lang, at: VTOFFSET.lang.p) }
  public static func addVectorOf(titles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: titles, at: VTOFFSET.titles.p) }
  public static func endSurahTitlesI18n(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createSurahTitlesI18n(
    _ fbb: inout FlatBufferBuilder,
    langOffset lang: Offset = Offset(),
    titlesVectorOffset titles: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahTitlesI18n.startSurahTitlesI18n(&fbb)
    com_quranic_wholequran_fbs_SurahTitlesI18n.add(lang: lang, &fbb)
    com_quranic_wholequran_fbs_SurahTitlesI18n.addVectorOf(titles: titles, &fbb)
    return com_quranic_wholequran_fbs_SurahTitlesI18n.endSurahTitlesI18n(&fbb, start: __start)
  }
  public static func sortVectorOfSurahTitlesI18n(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahTitlesI18n? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_SurahTitlesI18n(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_SurahTitles: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahTitles(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahTitles { return com_quranic_wholequran_fbs_SurahTitles(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case surahTitles = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var surahTitlesCount: Int32 { let o = _accessor.offset(VTOFFSET.surahTitles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func surahTitles(at index: Int32) -> com_quranic_wholequran_fbs_SurahTitlesI18n? { let o = _accessor.offset(VTOFFSET.surahTitles.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahTitlesI18n(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func surahTitlesBy(key: String) -> com_quranic_wholequran_fbs_SurahTitlesI18n? { let o = _accessor.offset(VTOFFSET.surahTitles.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahTitlesI18n.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startSurahTitles(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(surahTitles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: surahTitles, at: VTOFFSET.surahTitles.p) }
  public static func endSurahTitles(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurahTitles(
    _ fbb: inout FlatBufferBuilder,
    surahTitlesVectorOffset surahTitles: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahTitles.startSurahTitles(&fbb)
    com_quranic_wholequran_fbs_SurahTitles.addVectorOf(surahTitles: surahTitles, &fbb)
    return com_quranic_wholequran_fbs_SurahTitles.endSurahTitles(&fbb, start: __start)
  }
}

