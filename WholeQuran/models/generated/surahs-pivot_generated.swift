// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_SurahsPivotPos: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahsPivotPos(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahsPivotPos { return com_quranic_wholequran_fbs_SurahsPivotPos(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case surah = 4
    case ayah = 6
    case pos = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var surah: Int32 { let o = _accessor.offset(VTOFFSET.surah.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var ayah: Int32 { let o = _accessor.offset(VTOFFSET.ayah.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var pos: Int32 { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startSurahsPivotPos(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(surah: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: surah, def: 0, at: VTOFFSET.surah.p) }
  public static func add(ayah: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ayah, def: 0, at: VTOFFSET.ayah.p) }
  public static func add(pos: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pos, def: 0, at: VTOFFSET.pos.p) }
  public static func endSurahsPivotPos(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurahsPivotPos(
    _ fbb: inout FlatBufferBuilder,
    surah: Int32 = 0,
    ayah: Int32 = 0,
    pos: Int32 = 0
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahsPivotPos.startSurahsPivotPos(&fbb)
    com_quranic_wholequran_fbs_SurahsPivotPos.add(surah: surah, &fbb)
    com_quranic_wholequran_fbs_SurahsPivotPos.add(ayah: ayah, &fbb)
    com_quranic_wholequran_fbs_SurahsPivotPos.add(pos: pos, &fbb)
    return com_quranic_wholequran_fbs_SurahsPivotPos.endSurahsPivotPos(&fbb, start: __start)
  }
}

public struct com_quranic_wholequran_fbs_SurahsPivotWordEntry: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahsPivotWordEntry(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahsPivotWordEntry { return com_quranic_wholequran_fbs_SurahsPivotWordEntry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case word = 4
    case positions = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var word: String! { let o = _accessor.offset(VTOFFSET.word.v); return _accessor.string(at: o) }
  public var wordSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.word.v) }
  public var positionsCount: Int32 { let o = _accessor.offset(VTOFFSET.positions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func positions(at index: Int32) -> com_quranic_wholequran_fbs_SurahsPivotPos? { let o = _accessor.offset(VTOFFSET.positions.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahsPivotPos(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startSurahsPivotWordEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(word: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: word, at: VTOFFSET.word.p) }
  public static func addVectorOf(positions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: positions, at: VTOFFSET.positions.p) }
  public static func endSurahsPivotWordEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createSurahsPivotWordEntry(
    _ fbb: inout FlatBufferBuilder,
    wordOffset word: Offset = Offset(),
    positionsVectorOffset positions: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahsPivotWordEntry.startSurahsPivotWordEntry(&fbb)
    com_quranic_wholequran_fbs_SurahsPivotWordEntry.add(word: word, &fbb)
    com_quranic_wholequran_fbs_SurahsPivotWordEntry.addVectorOf(positions: positions, &fbb)
    return com_quranic_wholequran_fbs_SurahsPivotWordEntry.endSurahsPivotWordEntry(&fbb, start: __start)
  }
  public static func sortVectorOfSurahsPivotWordEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahsPivotWordEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_SurahsPivotWordEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_SurahsPivot: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSurahsPivot(bb: ByteBuffer) -> com_quranic_wholequran_fbs_SurahsPivot { return com_quranic_wholequran_fbs_SurahsPivot(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case entries = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var entriesCount: Int32 { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func entries(at index: Int32) -> com_quranic_wholequran_fbs_SurahsPivotWordEntry? { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahsPivotWordEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func entriesBy(key: String) -> com_quranic_wholequran_fbs_SurahsPivotWordEntry? { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? nil : com_quranic_wholequran_fbs_SurahsPivotWordEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startSurahsPivot(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(entries: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: entries, at: VTOFFSET.entries.p) }
  public static func endSurahsPivot(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSurahsPivot(
    _ fbb: inout FlatBufferBuilder,
    entriesVectorOffset entries: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_SurahsPivot.startSurahsPivot(&fbb)
    com_quranic_wholequran_fbs_SurahsPivot.addVectorOf(entries: entries, &fbb)
    return com_quranic_wholequran_fbs_SurahsPivot.endSurahsPivot(&fbb, start: __start)
  }
}

