// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_CorpusPivotEntryLocation: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpusPivotEntryLocation(bb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusPivotEntryLocation { return com_quranic_wholequran_fbs_CorpusPivotEntryLocation(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case surah = 4
    case ayah = 6
    case word = 8
    case part = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var surah: Int32 { let o = _accessor.offset(VTOFFSET.surah.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var ayah: Int32 { let o = _accessor.offset(VTOFFSET.ayah.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var word: Int32 { let o = _accessor.offset(VTOFFSET.word.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var part: Int32 { let o = _accessor.offset(VTOFFSET.part.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startCorpusPivotEntryLocation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(surah: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: surah, def: 0, at: VTOFFSET.surah.p) }
  public static func add(ayah: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ayah, def: 0, at: VTOFFSET.ayah.p) }
  public static func add(word: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: word, def: 0, at: VTOFFSET.word.p) }
  public static func add(part: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: part, def: 0, at: VTOFFSET.part.p) }
  public static func endCorpusPivotEntryLocation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCorpusPivotEntryLocation(
    _ fbb: inout FlatBufferBuilder,
    surah: Int32 = 0,
    ayah: Int32 = 0,
    word: Int32 = 0,
    part: Int32 = 0
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_CorpusPivotEntryLocation.startCorpusPivotEntryLocation(&fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntryLocation.add(surah: surah, &fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntryLocation.add(ayah: ayah, &fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntryLocation.add(word: word, &fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntryLocation.add(part: part, &fbb)
    return com_quranic_wholequran_fbs_CorpusPivotEntryLocation.endCorpusPivotEntryLocation(&fbb, start: __start)
  }
}

public struct com_quranic_wholequran_fbs_CorpusPivotEntry: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpusPivotEntry(bb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusPivotEntry { return com_quranic_wholequran_fbs_CorpusPivotEntry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case locations = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String! { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var locationsCount: Int32 { let o = _accessor.offset(VTOFFSET.locations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func locations(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntryLocation? { let o = _accessor.offset(VTOFFSET.locations.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntryLocation(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startCorpusPivotEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func addVectorOf(locations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: locations, at: VTOFFSET.locations.p) }
  public static func endCorpusPivotEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createCorpusPivotEntry(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    locationsVectorOffset locations: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_CorpusPivotEntry.startCorpusPivotEntry(&fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntry.add(id: id, &fbb)
    com_quranic_wholequran_fbs_CorpusPivotEntry.addVectorOf(locations: locations, &fbb)
    return com_quranic_wholequran_fbs_CorpusPivotEntry.endCorpusPivotEntry(&fbb, start: __start)
  }
  public static func sortVectorOfCorpusPivotEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusPivotEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_CorpusPivotEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_CorpusPivot: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpusPivot(bb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusPivot { return com_quranic_wholequran_fbs_CorpusPivot(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case lem = 4
    case lemc = 6
    case form = 8
    case formc = 10
    case exact = 12
    case consonant = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var lemCount: Int32 { let o = _accessor.offset(VTOFFSET.lem.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func lem(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.lem.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func lemBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.lem.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var lemcCount: Int32 { let o = _accessor.offset(VTOFFSET.lemc.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func lemc(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.lemc.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func lemcBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.lemc.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var formCount: Int32 { let o = _accessor.offset(VTOFFSET.form.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func form(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.form.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func formBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.form.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var formcCount: Int32 { let o = _accessor.offset(VTOFFSET.formc.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func formc(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.formc.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func formcBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.formc.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var exactCount: Int32 { let o = _accessor.offset(VTOFFSET.exact.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func exact(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.exact.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func exactBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.exact.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var consonantCount: Int32 { let o = _accessor.offset(VTOFFSET.consonant.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func consonant(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.consonant.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func consonantBy(key: String) -> com_quranic_wholequran_fbs_CorpusPivotEntry? { let o = _accessor.offset(VTOFFSET.consonant.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPivotEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startCorpusPivot(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func addVectorOf(lem: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lem, at: VTOFFSET.lem.p) }
  public static func addVectorOf(lemc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lemc, at: VTOFFSET.lemc.p) }
  public static func addVectorOf(form: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: form, at: VTOFFSET.form.p) }
  public static func addVectorOf(formc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: formc, at: VTOFFSET.formc.p) }
  public static func addVectorOf(exact: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: exact, at: VTOFFSET.exact.p) }
  public static func addVectorOf(consonant: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: consonant, at: VTOFFSET.consonant.p) }
  public static func endCorpusPivot(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCorpusPivot(
    _ fbb: inout FlatBufferBuilder,
    lemVectorOffset lem: Offset = Offset(),
    lemcVectorOffset lemc: Offset = Offset(),
    formVectorOffset form: Offset = Offset(),
    formcVectorOffset formc: Offset = Offset(),
    exactVectorOffset exact: Offset = Offset(),
    consonantVectorOffset consonant: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_CorpusPivot.startCorpusPivot(&fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(lem: lem, &fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(lemc: lemc, &fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(form: form, &fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(formc: formc, &fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(exact: exact, &fbb)
    com_quranic_wholequran_fbs_CorpusPivot.addVectorOf(consonant: consonant, &fbb)
    return com_quranic_wholequran_fbs_CorpusPivot.endCorpusPivot(&fbb, start: __start)
  }
}

