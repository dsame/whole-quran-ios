// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct com_quranic_wholequran_fbs_CorpusPartEntry: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpusPartEntry(bb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusPartEntry { return com_quranic_wholequran_fbs_CorpusPartEntry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case form = 4
    case lem = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var form: String? { let o = _accessor.offset(VTOFFSET.form.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var formSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.form.v) }
  public var lem: String? { let o = _accessor.offset(VTOFFSET.lem.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lemSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.lem.v) }
  public static func startCorpusPartEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(form: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: form, at: VTOFFSET.form.p) }
  public static func add(lem: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lem, at: VTOFFSET.lem.p) }
  public static func endCorpusPartEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCorpusPartEntry(
    _ fbb: inout FlatBufferBuilder,
    formOffset form: Offset = Offset(),
    lemOffset lem: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_CorpusPartEntry.startCorpusPartEntry(&fbb)
    com_quranic_wholequran_fbs_CorpusPartEntry.add(form: form, &fbb)
    com_quranic_wholequran_fbs_CorpusPartEntry.add(lem: lem, &fbb)
    return com_quranic_wholequran_fbs_CorpusPartEntry.endCorpusPartEntry(&fbb, start: __start)
  }
}

public struct com_quranic_wholequran_fbs_CorpusWordEntry: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpusWordEntry(bb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusWordEntry { return com_quranic_wholequran_fbs_CorpusWordEntry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case index = 4
    case parts = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var index: String! { let o = _accessor.offset(VTOFFSET.index.v); return _accessor.string(at: o) }
  public var indexSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.index.v) }
  public var partsCount: Int32 { let o = _accessor.offset(VTOFFSET.parts.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func parts(at index: Int32) -> com_quranic_wholequran_fbs_CorpusPartEntry? { let o = _accessor.offset(VTOFFSET.parts.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusPartEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startCorpusWordEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(index: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: index, at: VTOFFSET.index.p) }
  public static func addVectorOf(parts: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: parts, at: VTOFFSET.parts.p) }
  public static func endCorpusWordEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createCorpusWordEntry(
    _ fbb: inout FlatBufferBuilder,
    indexOffset index: Offset = Offset(),
    partsVectorOffset parts: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_CorpusWordEntry.startCorpusWordEntry(&fbb)
    com_quranic_wholequran_fbs_CorpusWordEntry.add(index: index, &fbb)
    com_quranic_wholequran_fbs_CorpusWordEntry.addVectorOf(parts: parts, &fbb)
    return com_quranic_wholequran_fbs_CorpusWordEntry.endCorpusWordEntry(&fbb, start: __start)
  }
  public static func sortVectorOfCorpusWordEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> com_quranic_wholequran_fbs_CorpusWordEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return com_quranic_wholequran_fbs_CorpusWordEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }
}

public struct com_quranic_wholequran_fbs_Corpus: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsCorpus(bb: ByteBuffer) -> com_quranic_wholequran_fbs_Corpus { return com_quranic_wholequran_fbs_Corpus(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case words = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var wordsCount: Int32 { let o = _accessor.offset(VTOFFSET.words.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func words(at index: Int32) -> com_quranic_wholequran_fbs_CorpusWordEntry? { let o = _accessor.offset(VTOFFSET.words.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusWordEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func wordsBy(key: String) -> com_quranic_wholequran_fbs_CorpusWordEntry? { let o = _accessor.offset(VTOFFSET.words.v); return o == 0 ? nil : com_quranic_wholequran_fbs_CorpusWordEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startCorpus(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(words: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: words, at: VTOFFSET.words.p) }
  public static func endCorpus(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCorpus(
    _ fbb: inout FlatBufferBuilder,
    wordsVectorOffset words: Offset = Offset()
  ) -> Offset {
    let __start = com_quranic_wholequran_fbs_Corpus.startCorpus(&fbb)
    com_quranic_wholequran_fbs_Corpus.addVectorOf(words: words, &fbb)
    return com_quranic_wholequran_fbs_Corpus.endCorpus(&fbb, start: __start)
  }
}

